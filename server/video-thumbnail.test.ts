import { describe, it, expect, vi, beforeEach } from 'vitest';
import * as fs from 'fs';

// Mock child_process.execFile with promisify support
const mockExecFile = vi.fn();
vi.mock('child_process', () => ({
  execFile: (...args: any[]) => mockExecFile(...args),
}));

// Mock util.promisify to return our controlled async function
vi.mock('util', async (importOriginal) => {
  const actual = await importOriginal() as any;
  return {
    ...actual,
    promisify: (fn: any) => {
      // Return an async wrapper that calls our mock
      return async (...args: any[]) => {
        return new Promise((resolve, reject) => {
          mockExecFile(...args, (err: any, result: any) => {
            if (err) reject(err);
            else resolve(result);
          });
        });
      };
    },
  };
});

// Mock storagePut
const mockStoragePut = vi.fn().mockResolvedValue({
  key: 'user-1/thumbnails/test-thumb.jpg',
  url: 'https://cdn.example.com/user-1/thumbnails/test-thumb.jpg',
});

vi.mock('../server/storage', () => ({
  storagePut: (...args: any[]) => mockStoragePut(...args),
}));

describe('Video Thumbnail Generation', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Default: FFmpeg creates a fake output file
    mockExecFile.mockImplementation((...args: any[]) => {
      const callback = args[args.length - 1];
      // The output file is the second-to-last arg before callback, or last of the ffmpeg args
      const ffmpegArgs = args[1] as string[];
      const outputFile = ffmpegArgs[ffmpegArgs.length - 1];
      fs.writeFileSync(outputFile, Buffer.from('fake-jpeg-data'));
      if (typeof callback === 'function') callback(null, { stdout: '', stderr: '' });
    });
    mockStoragePut.mockResolvedValue({
      key: 'user-1/thumbnails/test-thumb.jpg',
      url: 'https://cdn.example.com/user-1/thumbnails/test-thumb.jpg',
    });
  });

  it('should export generateVideoThumbnail function', async () => {
    const mod = await import('./lib/videoThumbnail');
    expect(mod.generateVideoThumbnail).toBeDefined();
    expect(typeof mod.generateVideoThumbnail).toBe('function');
  });

  it('should call FFmpeg with correct arguments', async () => {
    const { generateVideoThumbnail } = await import('./lib/videoThumbnail');

    await generateVideoThumbnail('https://cdn.example.com/video.mp4', {
      userId: 1,
      filename: 'test-video.mp4',
      seekTime: 2,
      width: 320,
      quality: 3,
    });

    expect(mockExecFile).toHaveBeenCalled();
    const ffmpegArgs = mockExecFile.mock.calls[0][0] as string[];
    // The promisified version passes all args directly
    // First arg should contain '-ss', '2', '-i', url, etc.
    const allArgs = [mockExecFile.mock.calls[0][0], ...mockExecFile.mock.calls[0][1]].flat();
    expect(allArgs).toContain('-ss');
    expect(allArgs).toContain('-i');
    expect(allArgs).toContain('-vframes');
    expect(allArgs).toContain('1');
  });

  it('should return thumbnail URL and key on success', async () => {
    const { generateVideoThumbnail } = await import('./lib/videoThumbnail');

    const result = await generateVideoThumbnail('https://cdn.example.com/video.mp4', {
      userId: 1,
      filename: 'test-video.mp4',
    });

    expect(result).not.toBeNull();
    // URL comes from the mock storagePut
    expect(result!.url).toBe('https://cdn.example.com/user-1/thumbnails/test-thumb.jpg');
    // Key is generated by the function itself
    expect(result!.key).toMatch(/^user-1\/thumbnails\/\d+-[a-z0-9]+-test-video\.jpg$/);
  });

  it('should call storagePut with image/jpeg content type', async () => {
    const { generateVideoThumbnail } = await import('./lib/videoThumbnail');

    await generateVideoThumbnail('https://cdn.example.com/video.mp4', {
      userId: 42,
      filename: 'my-video.mp4',
    });

    expect(mockStoragePut).toHaveBeenCalledTimes(1);
    const [key, , contentType] = mockStoragePut.mock.calls[0];
    expect(key).toMatch(/^user-42\/thumbnails\//);
    expect(key).toContain('my-video');
    expect(key).toMatch(/\.jpg$/);
    expect(contentType).toBe('image/jpeg');
  });

  it('should return null when FFmpeg fails', async () => {
    mockExecFile.mockImplementationOnce((...args: any[]) => {
      const callback = args[args.length - 1];
      if (typeof callback === 'function') callback(new Error('FFmpeg crashed'), null);
    });

    const { generateVideoThumbnail } = await import('./lib/videoThumbnail');

    const result = await generateVideoThumbnail('https://cdn.example.com/video.mp4', {
      userId: 1,
      filename: 'test-video.mp4',
    });

    expect(result).toBeNull();
  });

  it('should return null when storagePut fails', async () => {
    mockStoragePut.mockRejectedValueOnce(new Error('Upload failed'));

    const { generateVideoThumbnail } = await import('./lib/videoThumbnail');

    const result = await generateVideoThumbnail('https://cdn.example.com/video.mp4', {
      userId: 1,
      filename: 'test-video.mp4',
    });

    expect(result).toBeNull();
  });
});
